Import C libraries here

Import function prototypes here

// Main
int main(argc, argv[], *maybe put environment var pointer here*) {
    declare a flag to determine what we want future execution to be (execFlag)
    
    // if only one argument is provided then we are in interactive mode
    if(argc == 1) {
        while(always true so it constantly runs) {
            print beginning terminal tag

            declare char *pointer to store value of reading a line (function read_line)
            declare char **pointer to store array of values/arguments for a line (function split_line)

            declare execFlag equal to processString function which will return an integer
            of what mode of input you are receiving

            // if execFlag equals 0 then there is no command or a built-in command
            // if execFlag equals 1 then there is a simple command (that doesn't require a pipe)
            // if execFlag equals 2 then there is a command that involves a pipe 

            free char *pointer above
            free char **pointer above
        }
    }
    else if(argc == 2) {
        // we are in batch mode
    }
    else {
        invalid # of arguments
    }
}

// Function to process a string
int processString(intake entire string, the parased arguments, and the parsed arguments that are piped) {
    declare char* with a length of 2
    declare an integer as 0 of whether there is a pipe present
    
    declare above integer equal to parsePipe command (this function will see if there is a pipe present)
    
    if(piped is true) {
        then run the parseSpace function using the left side of the argument
        then run the parseSpace function using the right side of the argument
    }
    else {
        then run the parseSpace function using the full string and the char* string pipe
    }
    
    // commandHandler function returns true (which means there's possible execution)
    if(commandHandler(paresed)) {
        return 0 // there is no command or a built-in command
    }
    else {
        return 1 + piped // there is a simple command or a command that involves a pipe
    }
}

// Function to parse a string of commands to find a pipe
int parseCommandPipe(char* strings, char** strings that could be piped) {
    // for loop that goes through each side of commands to see if pipe is present
    for(i=0; i<2; i++) {
        reassign the strings that could be piped to strsep that intakes the string and char "|"
        if(strpiped is NULL) {
            then break out because we may have found a pipe
        }
    }
    
    if (the first element of strpiped is null) {
        then we return 0 cause no pipes were found
    }
    else {
        then we return 1 cause a pipe was found
    }
}

// Function to parse command words
void parseCommandWords(char* str, char** paresedStrings) {
    // for loop that removes the space if a pipe is present in general string
    for(int i=0; i<capacity; i++) {
        parsedStrings[i] = strsep // seperate the space from the side of the pipe string
        // if (paresedString[i] == NULL) {
            break
        }
        if (the length of parsedString is equal to 0) {
            then we decrement i to find again that space
        }
    }
}

// Function to read a line
char* read_line() {
    declare a char* pointer of the line we will read (NULL)
    declare a buflen of zero since we don't know how long the line will be
    run getline function that intakes
        the address of line, the address of buflen, and that it's a stdin
    finally return the entire line back to function
}

// Function to split line into arguments
char** split_line(intake the line we just read) {
    declare int length so that we use it later with tokens
    declare int capacity so that we restrict the amount of arguments that can be processed in a single line
    declare char **tokens to equal the length of a given line multipled by the argument capacity (above)
    
    declare char *delimiters so that we know when we are looking at the next token ( \t\r\n)
    declare char *token that equals strtok with inputs of the line and the delimiters
    
    while(we still have tokens to read) {
        token"s" with an array value of length (setup above) will equal the new token (aka we are looking at the first token)
        increment length (so that we know which token we are looking at)
        
        if(the # of tokens (length) is greater than or equal to capacity) {
            then reassign capacity to a higher value (of about 1.5 times more)
            reassign tokens to realloc more memory that intakes (tokens, capacity * sizeof(char*))
        }
        
        reassign token to strtok(NULL, delimiters)
    }
    
    reassign the last token with value NULL
    return tokens
}

// Function to execute process
void exec(char **args) {
    declare child_pid to equal a fork()
    
    if the child_pid is zero (aka it's a child process) {
        execute a process using the first argument and args
        declare a perror incase the execution fails
        exit(1) aka failure
    }
    else if (the child_pid is greater than 0 then it's a parent process) {
        declare a status integer
        do this action {
            waitpid for the child process to execute then change the statusid
        } while we wait for the status to change
    }
    else {
        declare a perror incase all else fails
    }
}

// Function to execute built-in command exit
void exit(char **args) {
    exit(0) function was a success
}

// Function to execute built-in command cd
void cd(char **args) {
    if(no directory was given in args[1]) {
        print out an error saying that there's a missing argument
    }
    else {
        if(change if the 2nd argument of chdir isn't 0 then we don't have a directory to switch to) {
            print out an error 
        }
    }
}

// Function to execute built-in command help
void help(char **args) {
    declare char *help to display all text
        include the name of the shell and all the possible arguments the user can use
    printf the char *help to the screen
}

// Function to execute builtin commands
int commandHandler(char** parsedStrings) {
    declare # of built in commands present in shell
    declare a char array of list of own commands
    declare a char array for username
    
    initalize each built in command like so
    ListOfBuiltInCommands[0] = "help";
    ListOfBuiltInCommands[0] = "cd";
    
    // make a for loop that determines which command the user wants
    for(int i=0; i< # of commands; i++) {
        if(the first parsed string and the specific list of built of commands is equal) {
            then increment the counter for later switch cases use
        }
    }
    
    // HAVE A CASE PRESENT FOR EACH BUILT IN COMMANDS THAT RELATES TO THE ARRAY ABOVE
    switch(counter from above) {
        case 1 to n:
            printf("Executing command");
        default:
            break;
    }
    return 0;
}

// put in rest of built in commands
a. cd <directory> - Change the current default directory to
<directory>. If the <directory> argument is not present, report the current directory. If the directory does not exist an appropriate error should be reported. This command should also change the PWD environment variable.
b. clr - Clear the screen.
c. dir <directory> - List the contents of directory <directory>.
d. environ - List all the environment strings.
e. echo <comment> - Display <comment> on the display followed by a new line (multiple spaces/tabs may be reduced to a single space).
f. help - Display the user manual using the more filter.
g. pause - Pause operation of the shell until 'Enter' is pressed.
h. quit - Quit the shell.
i. The shell environment should contain shell=<pathname>/myshell where <pathname>/myshell is the full path for the shell executable(not a hardwired path back to your directory, but the one from which it was executed).
// put in redirection
// put piped system commands
HAVEN'T STARTED Finish the rest of the built-in commands and make sure they work
HAVEN'T STARTED start by implementing fork() when command isn't built in
HAVEN'T STARTED then implement exec() and wait() once you've figured out fork
HAVEN'T STARTED then shell can execute both built-ins and external commands
HAVEN'T STARTED it will be easier to implement flag handling once core shell is programmed
